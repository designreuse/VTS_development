/**
 * generated by Voice CodeGen Version: Beta_R1_v0.1.0
 * generated on: Thu Sep 10 18:55:36 IST 2015
 */

#include "Arrays_3TesseractProxy.hpp"

namespace v0_1 {
namespace com {
namespace harman {
namespace voice {

std::shared_ptr<CommonAPI::Tesseract::CTesseractProxy> createArrays_3TesseractProxy(
	const CommonAPI::Address &_address)
{
    return std::make_shared<Arrays_3TesseractProxy>(_address);
}

INITIALIZER(registercalculatorTesseractProxy)
{
	CommonAPI::Tesseract::CTesseractFactory::get()->registerProxyCreateMethod(
		Arrays_3::getInterface(),
		&createArrays_3TesseractProxy);
}

Arrays_3TesseractProxy::Arrays_3TesseractProxy(
	const CommonAPI::Address &_address)
: CommonAPI::Tesseract::CTesseractProxy(_address)
{
}

Arrays_3TesseractProxy::~Arrays_3TesseractProxy()
{
}

void Arrays_3TesseractProxy::getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const
{	
	ownVersionMajor = 0;
	ownVersionMinor = 1;
}

void Arrays_3TesseractProxy::route(const std::vector<::v0_1::com::harman::voice::Arrays_3::latlong>& latLong, CommonAPI::CallStatus& callStatus, std::vector<::v0_1::com::harman::voice::Arrays_3::latlong>& path, const CommonAPI::CallInfo *_info)
{
	std::string uri(CommonAPI::Proxy::address_.getInterface()+ "." +CommonAPI::Proxy::address_.getInstance() + ".route");
	
	std::string argL;
	std::string errorL;
	std::string replyL;
	
	if(serialize_params(argL, latLong))
	{
		callStatus = CommonAPI::Tesseract::CTesseractProxy::callMethodWithReply(uri, argL, errorL, replyL);
		if(CommonAPI::CallStatus::SUCCESS == callStatus && !deserialize_params(replyL, path))
		{
			callStatus = CommonAPI::CallStatus::OUT_OF_MEMORY;
		}
	}
	else
	{
		callStatus = CommonAPI::CallStatus::OUT_OF_MEMORY;
	}
}

std::future<CommonAPI::CallStatus> Arrays_3TesseractProxy::routeAsync(const std::vector<::v0_1::com::harman::voice::Arrays_3::latlong>& latLong, RouteAsyncCallback callback, const CommonAPI::CallInfo *_info)
{
	typedef CommonAPI::Tesseract::CAsyncCallbackHandler<std::vector<::v0_1::com::harman::voice::Arrays_3::latlong>> asynchandler_t;
	
	std::string uri(CommonAPI::Proxy::address_.getInterface()+ "." +CommonAPI::Proxy::address_.getInstance() + ".route");

	std::string argL;

	if(serialize_params(argL, latLong))
	{
		std::shared_ptr<asynchandler_t> asyncCallbackHandler = asynchandler_t::create((std::move(callback)));
		CommonAPI::Tesseract::CTesseractProxy::callMethodAsync(
			uri,
			argL,
			std::bind(&asynchandler_t::callCb, asyncCallbackHandler, std::placeholders::_1, std::placeholders::_2),
			std::bind(&asynchandler_t::callErrorCb, asyncCallbackHandler, std::placeholders::_1, std::placeholders::_2),
			std::bind(&asynchandler_t::replyCb, asyncCallbackHandler, std::placeholders::_1, std::placeholders::_2),
			this);
		return asyncCallbackHandler->getFuture();
	}
	else
	{
		// fixme: will this work?
		std::promise<CommonAPI::CallStatus> promise;
		promise.set_value(CommonAPI::CallStatus::OUT_OF_MEMORY);
		return promise.get_future();
	}
}

void Arrays_3TesseractProxy::getShortestRoute(const ::v0_1::com::harman::voice::Arrays_3::latlong& latLongStructure, CommonAPI::CallStatus& callStatus, std::vector<::v0_1::com::harman::voice::Arrays_3::latlong>& path, const CommonAPI::CallInfo *_info)
{
	std::string uri(CommonAPI::Proxy::address_.getInterface()+ "." +CommonAPI::Proxy::address_.getInstance() + ".getShortestRoute");
	
	std::string argL;
	std::string errorL;
	std::string replyL;
	
	if(serialize_params(argL, latLongStructure))
	{
		callStatus = CommonAPI::Tesseract::CTesseractProxy::callMethodWithReply(uri, argL, errorL, replyL);
		if(CommonAPI::CallStatus::SUCCESS == callStatus && !deserialize_params(replyL, path))
		{
			callStatus = CommonAPI::CallStatus::OUT_OF_MEMORY;
		}
	}
	else
	{
		callStatus = CommonAPI::CallStatus::OUT_OF_MEMORY;
	}
}

std::future<CommonAPI::CallStatus> Arrays_3TesseractProxy::getShortestRouteAsync(const ::v0_1::com::harman::voice::Arrays_3::latlong& latLongStructure, GetShortestRouteAsyncCallback callback, const CommonAPI::CallInfo *_info)
{
	typedef CommonAPI::Tesseract::CAsyncCallbackHandler<std::vector<::v0_1::com::harman::voice::Arrays_3::latlong>> asynchandler_t;
	
	std::string uri(CommonAPI::Proxy::address_.getInterface()+ "." +CommonAPI::Proxy::address_.getInstance() + ".getShortestRoute");

	std::string argL;

	if(serialize_params(argL, latLongStructure))
	{
		std::shared_ptr<asynchandler_t> asyncCallbackHandler = asynchandler_t::create((std::move(callback)));
		CommonAPI::Tesseract::CTesseractProxy::callMethodAsync(
			uri,
			argL,
			std::bind(&asynchandler_t::callCb, asyncCallbackHandler, std::placeholders::_1, std::placeholders::_2),
			std::bind(&asynchandler_t::callErrorCb, asyncCallbackHandler, std::placeholders::_1, std::placeholders::_2),
			std::bind(&asynchandler_t::replyCb, asyncCallbackHandler, std::placeholders::_1, std::placeholders::_2),
			this);
		return asyncCallbackHandler->getFuture();
	}
	else
	{
		// fixme: will this work?
		std::promise<CommonAPI::CallStatus> promise;
		promise.set_value(CommonAPI::CallStatus::OUT_OF_MEMORY);
		return promise.get_future();
	}
}

void Arrays_3TesseractProxy::getPOI(const ::v0_1::com::harman::voice::Arrays_3::latlong& latLongStruct, CommonAPI::CallStatus& callStatus, ::v0_1::com::harman::voice::Arrays_3::POIS_NAME& poisName, const CommonAPI::CallInfo *_info)
{
	std::string uri(CommonAPI::Proxy::address_.getInterface()+ "." +CommonAPI::Proxy::address_.getInstance() + ".getPOI");
	
	std::string argL;
	std::string errorL;
	std::string replyL;
	
	if(serialize_params(argL, latLongStruct))
	{
		callStatus = CommonAPI::Tesseract::CTesseractProxy::callMethodWithReply(uri, argL, errorL, replyL);
		if(CommonAPI::CallStatus::SUCCESS == callStatus && !deserialize_params(replyL, poisName))
		{
			callStatus = CommonAPI::CallStatus::OUT_OF_MEMORY;
		}
	}
	else
	{
		callStatus = CommonAPI::CallStatus::OUT_OF_MEMORY;
	}
}

std::future<CommonAPI::CallStatus> Arrays_3TesseractProxy::getPOIAsync(const ::v0_1::com::harman::voice::Arrays_3::latlong& latLongStruct, GetPOIAsyncCallback callback, const CommonAPI::CallInfo *_info)
{
	typedef CommonAPI::Tesseract::CAsyncCallbackHandler<::v0_1::com::harman::voice::Arrays_3::POIS_NAME> asynchandler_t;
	
	std::string uri(CommonAPI::Proxy::address_.getInterface()+ "." +CommonAPI::Proxy::address_.getInstance() + ".getPOI");

	std::string argL;

	if(serialize_params(argL, latLongStruct))
	{
		std::shared_ptr<asynchandler_t> asyncCallbackHandler = asynchandler_t::create((std::move(callback)));
		CommonAPI::Tesseract::CTesseractProxy::callMethodAsync(
			uri,
			argL,
			std::bind(&asynchandler_t::callCb, asyncCallbackHandler, std::placeholders::_1, std::placeholders::_2),
			std::bind(&asynchandler_t::callErrorCb, asyncCallbackHandler, std::placeholders::_1, std::placeholders::_2),
			std::bind(&asynchandler_t::replyCb, asyncCallbackHandler, std::placeholders::_1, std::placeholders::_2),
			this);
		return asyncCallbackHandler->getFuture();
	}
	else
	{
		// fixme: will this work?
		std::promise<CommonAPI::CallStatus> promise;
		promise.set_value(CommonAPI::CallStatus::OUT_OF_MEMORY);
		return promise.get_future();
	}
}


} // namespace voice
} // namespace harman
} // namespace com
} // namespace v0_1
